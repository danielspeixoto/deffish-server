// Code generated by MockGen. DO NOT EDIT.
// Source: src/boundary//question/Boundary.go

// Package question is a generated GoMock package.
package question

import (
	aggregates "deffish-server/src/aggregates"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockIRepository is a mock of IRepository interface
type MockIRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIRepositoryMockRecorder
}

// MockIRepositoryMockRecorder is the mock recorder for MockIRepository
type MockIRepositoryMockRecorder struct {
	mock *MockIRepository
}

// NewMockIRepository creates a new mock instance
func NewMockIRepository(ctrl *gomock.Controller) *MockIRepository {
	mock := &MockIRepository{ctrl: ctrl}
	mock.recorder = &MockIRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIRepository) EXPECT() *MockIRepositoryMockRecorder {
	return m.recorder
}

// Insert mocks base method
func (m *MockIRepository) Insert(arg0 aggregates.Question) (aggregates.Id, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", arg0)
	ret0, _ := ret[0].(aggregates.Id)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert
func (mr *MockIRepositoryMockRecorder) Insert(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockIRepository)(nil).Insert), arg0)
}

// RandomByTags mocks base method
func (m *MockIRepository) RandomByTags(amount int, tags []string) ([]aggregates.Question, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RandomByTags", amount, tags)
	ret0, _ := ret[0].([]aggregates.Question)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RandomByTags indicates an expected call of RandomByTags
func (mr *MockIRepositoryMockRecorder) RandomByTags(amount, tags interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RandomByTags", reflect.TypeOf((*MockIRepository)(nil).RandomByTags), amount, tags)
}

// Id mocks base method
func (m *MockIRepository) Id(id aggregates.Id) (aggregates.Question, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Id", id)
	ret0, _ := ret[0].(aggregates.Question)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Id indicates an expected call of Id
func (mr *MockIRepositoryMockRecorder) Id(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Id", reflect.TypeOf((*MockIRepository)(nil).Id), id)
}

// GetRelatedVideos mocks base method
func (m *MockIRepository) GetRelatedVideos(id aggregates.Id, start, count int) ([]aggregates.RelatedVideo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRelatedVideos", id, start, count)
	ret0, _ := ret[0].([]aggregates.RelatedVideo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRelatedVideos indicates an expected call of GetRelatedVideos
func (mr *MockIRepositoryMockRecorder) GetRelatedVideos(id, start, count interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRelatedVideos", reflect.TypeOf((*MockIRepository)(nil).GetRelatedVideos), id, start, count)
}

// Add mocks base method
func (m *MockIRepository) Add(id aggregates.Id, tag string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", id, tag)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add
func (mr *MockIRepositoryMockRecorder) Add(id, tag interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIRepository)(nil).Add), id, tag)
}

// MockIRandomByTagsUseCase is a mock of IRandomByTagsUseCase interface
type MockIRandomByTagsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIRandomByTagsUseCaseMockRecorder
}

// MockIRandomByTagsUseCaseMockRecorder is the mock recorder for MockIRandomByTagsUseCase
type MockIRandomByTagsUseCaseMockRecorder struct {
	mock *MockIRandomByTagsUseCase
}

// NewMockIRandomByTagsUseCase creates a new mock instance
func NewMockIRandomByTagsUseCase(ctrl *gomock.Controller) *MockIRandomByTagsUseCase {
	mock := &MockIRandomByTagsUseCase{ctrl: ctrl}
	mock.recorder = &MockIRandomByTagsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIRandomByTagsUseCase) EXPECT() *MockIRandomByTagsUseCaseMockRecorder {
	return m.recorder
}

// Random mocks base method
func (m *MockIRandomByTagsUseCase) Random(amount int, tags []string) ([]aggregates.Question, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Random", amount, tags)
	ret0, _ := ret[0].([]aggregates.Question)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Random indicates an expected call of Random
func (mr *MockIRandomByTagsUseCaseMockRecorder) Random(amount, tags interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Random", reflect.TypeOf((*MockIRandomByTagsUseCase)(nil).Random), amount, tags)
}

// MockIByIdUseCase is a mock of IByIdUseCase interface
type MockIByIdUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIByIdUseCaseMockRecorder
}

// MockIByIdUseCaseMockRecorder is the mock recorder for MockIByIdUseCase
type MockIByIdUseCaseMockRecorder struct {
	mock *MockIByIdUseCase
}

// NewMockIByIdUseCase creates a new mock instance
func NewMockIByIdUseCase(ctrl *gomock.Controller) *MockIByIdUseCase {
	mock := &MockIByIdUseCase{ctrl: ctrl}
	mock.recorder = &MockIByIdUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIByIdUseCase) EXPECT() *MockIByIdUseCaseMockRecorder {
	return m.recorder
}

// Id mocks base method
func (m *MockIByIdUseCase) Id(id aggregates.Id) (aggregates.Question, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Id", id)
	ret0, _ := ret[0].(aggregates.Question)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Id indicates an expected call of Id
func (mr *MockIByIdUseCaseMockRecorder) Id(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Id", reflect.TypeOf((*MockIByIdUseCase)(nil).Id), id)
}

// MockIUploadUseCase is a mock of IUploadUseCase interface
type MockIUploadUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIUploadUseCaseMockRecorder
}

// MockIUploadUseCaseMockRecorder is the mock recorder for MockIUploadUseCase
type MockIUploadUseCaseMockRecorder struct {
	mock *MockIUploadUseCase
}

// NewMockIUploadUseCase creates a new mock instance
func NewMockIUploadUseCase(ctrl *gomock.Controller) *MockIUploadUseCase {
	mock := &MockIUploadUseCase{ctrl: ctrl}
	mock.recorder = &MockIUploadUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIUploadUseCase) EXPECT() *MockIUploadUseCaseMockRecorder {
	return m.recorder
}

// Upload mocks base method
func (m *MockIUploadUseCase) Upload(arg0 aggregates.Question) (aggregates.Id, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upload", arg0)
	ret0, _ := ret[0].(aggregates.Id)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Upload indicates an expected call of Upload
func (mr *MockIUploadUseCaseMockRecorder) Upload(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upload", reflect.TypeOf((*MockIUploadUseCase)(nil).Upload), arg0)
}

// MockIAddTagUseCase is a mock of IAddTagUseCase interface
type MockIAddTagUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIAddTagUseCaseMockRecorder
}

// MockIAddTagUseCaseMockRecorder is the mock recorder for MockIAddTagUseCase
type MockIAddTagUseCaseMockRecorder struct {
	mock *MockIAddTagUseCase
}

// NewMockIAddTagUseCase creates a new mock instance
func NewMockIAddTagUseCase(ctrl *gomock.Controller) *MockIAddTagUseCase {
	mock := &MockIAddTagUseCase{ctrl: ctrl}
	mock.recorder = &MockIAddTagUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIAddTagUseCase) EXPECT() *MockIAddTagUseCaseMockRecorder {
	return m.recorder
}

// Add mocks base method
func (m *MockIAddTagUseCase) Add(id aggregates.Id, tag string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", id, tag)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add
func (mr *MockIAddTagUseCaseMockRecorder) Add(id, tag interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIAddTagUseCase)(nil).Add), id, tag)
}

// MockIGetRelatedVideos is a mock of IGetRelatedVideos interface
type MockIGetRelatedVideos struct {
	ctrl     *gomock.Controller
	recorder *MockIGetRelatedVideosMockRecorder
}

// MockIGetRelatedVideosMockRecorder is the mock recorder for MockIGetRelatedVideos
type MockIGetRelatedVideosMockRecorder struct {
	mock *MockIGetRelatedVideos
}

// NewMockIGetRelatedVideos creates a new mock instance
func NewMockIGetRelatedVideos(ctrl *gomock.Controller) *MockIGetRelatedVideos {
	mock := &MockIGetRelatedVideos{ctrl: ctrl}
	mock.recorder = &MockIGetRelatedVideosMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIGetRelatedVideos) EXPECT() *MockIGetRelatedVideosMockRecorder {
	return m.recorder
}

// GetRelatedVideos mocks base method
func (m *MockIGetRelatedVideos) GetRelatedVideos(id aggregates.Id, start, count int) ([]aggregates.RelatedVideo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRelatedVideos", id, start, count)
	ret0, _ := ret[0].([]aggregates.RelatedVideo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRelatedVideos indicates an expected call of GetRelatedVideos
func (mr *MockIGetRelatedVideosMockRecorder) GetRelatedVideos(id, start, count interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRelatedVideos", reflect.TypeOf((*MockIGetRelatedVideos)(nil).GetRelatedVideos), id, start, count)
}
